<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Introducing Photograph | jhchabran</title><meta name=keywords content="Ruby"><meta name=description content="Photograph is a really simple gem that provides to take screenshots of webpages as they are rendered in webkit. Give Photograph the url you want and that&rsquo;s all.
The interesting part is how easy this was to code !
{% end_excerpt %}
Throwing gems at it It&rsquo;s about using Capybara with Polteirgeist (which wraps PhantomJS) to take the screenshot itself, then use MiniMagick to crop if needed. Adding some Ruby around it makes the Ruby API :"><meta name=author content="J.H. Chabran"><link rel=canonical href=http://jhchabran.dev/posts/2013-01-10-introducing-photograph/><link rel=stylesheet href=https://use.typekit.net/pmg0uoe.css><link href=/assets/css/stylesheet.min.f12e8a3e88e7a0a98cde28893b674bf5adb5629a42bace74ca84312ee4921642.css integrity="sha256-8S6KPojnoKmM3iiJO2dL9a21YppCus50yoQxLuSSFkI=" rel="preload stylesheet" as=style><link rel=icon href=http://jhchabran.dev/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://jhchabran.dev/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://jhchabran.dev/favicon-32x32.png><link rel=apple-touch-icon href=http://jhchabran.dev/apple-touch-icon.png><link rel=mask-icon href=http://jhchabran.dev/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.83.1"><meta property="og:title" content="Introducing Photograph"><meta property="og:description" content="Photograph is a really simple gem that provides to take screenshots of webpages as they are rendered in webkit. Give Photograph the url you want and that&rsquo;s all.
The interesting part is how easy this was to code !
{% end_excerpt %}
Throwing gems at it It&rsquo;s about using Capybara with Polteirgeist (which wraps PhantomJS) to take the screenshot itself, then use MiniMagick to crop if needed. Adding some Ruby around it makes the Ruby API :"><meta property="og:type" content="article"><meta property="og:url" content="http://jhchabran.dev/posts/2013-01-10-introducing-photograph/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2013-01-10T00:00:00+00:00"><meta property="article:modified_time" content="2013-01-10T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Introducing Photograph"><meta name=twitter:description content="Photograph is a really simple gem that provides to take screenshots of webpages as they are rendered in webkit. Give Photograph the url you want and that&rsquo;s all.
The interesting part is how easy this was to code !
{% end_excerpt %}
Throwing gems at it It&rsquo;s about using Capybara with Polteirgeist (which wraps PhantomJS) to take the screenshot itself, then use MiniMagick to crop if needed. Adding some Ruby around it makes the Ruby API :"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://jhchabran.dev/posts/"},{"@type":"ListItem","position":2,"name":"Introducing Photograph","item":"http://jhchabran.dev/posts/2013-01-10-introducing-photograph/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Introducing Photograph","name":"Introducing Photograph","description":"Photograph is a really simple gem that provides to take screenshots of webpages as they are rendered in webkit. Give Photograph the url you want and that\u0026rsquo;s all.\nThe interesting part is how easy this was to code !\n{% end_excerpt %}\nThrowing gems at it It\u0026rsquo;s about using Capybara with Polteirgeist (which wraps PhantomJS) to take the screenshot itself, then use MiniMagick to crop if needed. Adding some Ruby around it makes the Ruby API :","keywords":["Ruby"],"articleBody":"Photograph is a really simple gem that provides to take screenshots of webpages as they are rendered in webkit. Give Photograph the url you want and that’s all.\nThe interesting part is how easy this was to code !\n{% end_excerpt %}\nThrowing gems at it It’s about using Capybara with Polteirgeist (which wraps PhantomJS) to take the screenshot itself, then use MiniMagick to crop if needed. Adding some Ruby around it makes the Ruby API :\n{% highlight ruby %} artist = Artist.new :url = “http://jhchabran.com”, :wait = 2\nartist.shoot! do |image| send_file image.path, :type = “png” end {% endhighlight %}\nQuite easy isn’t it ? Cropping can be done through the optionals parameters :x :y :w :h.\nDeciding when to take the screenshot is probably the only tricky part. You can either specify a timer through :wait or wait for some dive to appear with :selector = \".page\" for example.\nAs a webservice As photograph after all the layers ends by running webkit, it can be used to produce screenshots reflecting exactly the rendering got an a platform. The use case we had that led to coding photograph some months ago was requiring OSX rendering. As we had an iPad client rendering rich content fetched from the backend, we had to rely on screenshots when listing the different pages to avoid fully rendering them which would have been very costly, especially since listing don’t need any interaction at all.\nWell, as we were obviously not hosting our webservice on an OSX machine but on Heroku, a thin Sinatra layer was added to make calls from Heroku to Photograph, which was hosted on a Mac.\n GET http://photograph.somewhere.com/shoot?url=http://jhchabran.com\u0026selector=.page And it answers with a png within 1 to 3 seconds. Wrap that into a Delayed or Resque Job and problem solved.\nNeed more photographs ? Spawn more Sinatra instances !\nGood and bad parts What is really interesting there is the fact the code is so simple that there’s almost no room for bugs besides those that may be carried by the libraries photograph’s relies on. Obviously, Sinatra and Capybara are robusts, the only small issue we had was on Capybara-Webkit which had its webkit-server dying after being online for some hours. Switching to PhantomJS thanks to Polteirgeist solved the problem.\nBut such simple code comes with its limitations. Having GET requests that takes more than 2 seconds can be irritating. Plus scaling can be achieved in a much better way than having one webkit instance running per Sinatra.\nAs our use case require tons of screenshots, we finally switched to Url2Png which worked great so far. As we were already working with SAAS everywhere it really made sense to add some cash there and let people focused on that problem solving it for us.\nNevertheless if taking a few screenshots is all you need, firing some photograph instance is probably the simplest way to achieve it.\nUpcoming So far, I’m really surprised to see how simple all of this was to write. Photograph had been successfully used in production on two apps. Experience shows that adding some features to scale it would improve the whole usability and decrease the amount of code required to use it.\nI’m currently thinking of adding Resque to photograph, having one phantomjs instance per worker thus making scaling easy as COUNT=5 QUEUE=* rake resque:workers. The screenshot would be provided afterward with a POST uploading it to the web app that needs it, with the url specified in a callback parameter.\nThere also might be some work to be done to detect window.onload instead of the crappy wait timer, to speed up the whole process.\nGetting it Source are available here and as a gem gem install photograph then photograph -h 192.168.0.1 -p 8080 for example.\n","wordCount":"630","inLanguage":"en","datePublished":"2013-01-10T00:00:00Z","dateModified":"2013-01-10T00:00:00Z","author":{"@type":"Person","name":"J.H. Chabran"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://jhchabran.dev/posts/2013-01-10-introducing-photograph/"},"publisher":{"@type":"Organization","name":"jhchabran","logo":{"@type":"ImageObject","url":"http://jhchabran.dev/favicon.ico"}}}</script></head><body id=top><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style></noscript><header class=header><nav class=nav><div class=logo><a href=http://jhchabran.dev/ accesskey=h title="jhchabran (Alt + H)">jhchabran</a>
<span class=logo-switches></span></div><ul id=menu><li><a href=http://jhchabran.dev/about/ title=about><span>about</span></a></li><li><a href=http://jhchabran.dev/posts/ title=posts><span>posts</span></a></li><li><a href=http://jhchabran.dev/categories/ title=categories><span>categories</span></a></li><li><a href=http://jhchabran.dev/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Introducing Photograph</h1><div class=post-meta>January 10, 2013&nbsp;·&nbsp;3 min&nbsp;·&nbsp;J.H. Chabran</div></header><div class=post-content><p><a href=http://github.com/jhchabran/photograph/>Photograph</a> is a really simple
gem that provides to take screenshots of webpages as they are rendered
in webkit. Give Photograph the url you want and that&rsquo;s all.</p><p>The interesting part is how easy this was to code !</p><p>{% end_excerpt %}</p><h2 id=throwing-gems-at-it>Throwing gems at it<a hidden class=anchor aria-hidden=true href=#throwing-gems-at-it>#</a></h2><p>It&rsquo;s about using Capybara with Polteirgeist (which wraps PhantomJS) to take the screenshot itself, then use MiniMagick
to crop if needed. Adding some Ruby around it makes the Ruby API :</p><p>{% highlight ruby %}
artist = Artist.new :url => &ldquo;<a href=http://jhchabran.com>http://jhchabran.com</a>&rdquo;, :wait => 2</p><p>artist.shoot! do |image|
send_file image.path, :type => &ldquo;png&rdquo;
end
{% endhighlight %}</p><p>Quite easy isn&rsquo;t it ? Cropping can be done through the optionals
parameters <code>:x :y :w :h</code>.</p><p>Deciding when to take the screenshot is probably the only tricky part.
You can either specify a timer through <code>:wait</code> or wait for some dive
to appear with <code>:selector => ".page"</code> for example.</p><h2 id=as-a-webservice>As a webservice<a hidden class=anchor aria-hidden=true href=#as-a-webservice>#</a></h2><p>As photograph after all the layers ends by running webkit, it can be
used to produce screenshots reflecting exactly the rendering got an a
platform. The use case we had that led to coding photograph some months ago
was requiring OSX rendering. As we had an iPad client rendering rich
content fetched from the backend, we had to rely on screenshots when
listing the different pages to avoid fully rendering them which would
have been very costly, especially since listing don&rsquo;t need any
interaction at all.</p><p>Well, as we were obviously not hosting our webservice on an OSX machine
but on Heroku, a thin Sinatra layer was added to make calls from Heroku
to Photograph, which was hosted on a Mac.</p><pre><code>  GET
http://photograph.somewhere.com/shoot?url=http://jhchabran.com&amp;selector=.page
</code></pre><p>And it answers with a png within 1 to 3 seconds. Wrap that into a
Delayed or Resque Job and problem solved.</p><p>Need more photographs ? Spawn more Sinatra instances !</p><h2 id=good-and-bad-parts>Good and bad parts<a hidden class=anchor aria-hidden=true href=#good-and-bad-parts>#</a></h2><p>What is really interesting there is the fact the code is so simple that
there&rsquo;s almost no room for bugs besides those that may be carried by the
libraries photograph&rsquo;s relies on. Obviously, Sinatra and Capybara are
robusts, the only small issue we had was on Capybara-Webkit which had
its <code>webkit-server</code> dying after being online for some hours. Switching
to PhantomJS thanks to Polteirgeist solved the problem.</p><p>But such simple code comes with its limitations. Having GET requests
that takes more than 2 seconds can be irritating. Plus scaling can be
achieved in a much better way than having one webkit instance running
per Sinatra.</p><p>As our use case require tons of screenshots, we finally switched to
Url2Png which worked great so far. As we were already working with SAAS
everywhere it really made sense to add some cash there and let people
focused on that problem solving it for us.</p><p>Nevertheless if taking a few screenshots is all you need, firing some
photograph instance is probably the simplest way to achieve it.</p><h2 id=upcoming>Upcoming<a hidden class=anchor aria-hidden=true href=#upcoming>#</a></h2><p>So far, I&rsquo;m really surprised to see how simple all of this was to write.
Photograph had been successfully used in production on two apps.
Experience shows that adding some features to scale it would improve the
whole usability and decrease the amount of code required to use it.</p><p>I&rsquo;m currently thinking of adding Resque to photograph, having one
phantomjs instance per worker thus making scaling easy as <code>COUNT=5 QUEUE=* rake resque:workers</code>. The screenshot would be provided
afterward with a POST uploading it to the web app that needs it, with
the url specified in a <code>callback</code> parameter.</p><p>There also might be some work to be done to detect <code>window.onload</code>
instead of the crappy <code>wait</code> timer, to speed up the whole process.</p><h2 id=getting-it>Getting it<a hidden class=anchor aria-hidden=true href=#getting-it>#</a></h2><p><a href=https://github.com/jhchabran/photograph/>Source are available here</a>
and as a gem <code>gem install photograph</code> then <code>photograph -h 192.168.0.1 -p 8080</code> for example.</p></div><footer class=post-footer><ul class=post-tags><li><a href=http://jhchabran.dev/tags/ruby/>Ruby</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2021 <a href=http://jhchabran.dev/>jhchabran</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script></body></html>