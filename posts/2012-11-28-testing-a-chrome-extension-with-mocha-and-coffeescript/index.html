<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Testing a Chrome Extension with Mocha and CoffeeScript | jhchabran</title><meta name=keywords content="code"><meta name=description content="So we&rsquo;ve previously seen how to bootstrap a chrome extension with CoffeeScript. The next step is about adding testing support. Even if it&rsquo;s a simple extension, the whole process of reloading the extension in the browser to manually test a feature is incredibly boring and error prone.
{% end_excerpt %}
To illustrate, TabSwitcher will be used as an example, more specifically the match(url, abbreviation) function which returns a float, indicating how close is abbreviation is to url."><meta name=author content="J.H. Chabran"><link rel=canonical href=http://jhchabran.dev/posts/2012-11-28-testing-a-chrome-extension-with-mocha-and-coffeescript/><link crossorigin=anonymous href=/assets/css/stylesheet.min.a65a27fc4e81a2b15f42bbf617e1f4082b6ac47d3a90dd059a1ceaa73557b31b.css integrity="sha256-plon/E6BorFfQrv2F+H0CCtqxH06kN0FmhzqpzVXsxs=" rel="preload stylesheet" as=style><link rel=preload href=./avatar.jpg as=image><script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=http://jhchabran.dev/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://jhchabran.dev/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://jhchabran.dev/favicon-32x32.png><link rel=apple-touch-icon href=http://jhchabran.dev/apple-touch-icon.png><link rel=mask-icon href=http://jhchabran.dev/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.82.0"><link rel=stylesheet href=https://use.typekit.net/pmg0uoe.css><script async defer data-domain=jhchabran.dev src=https://plausible.io/js/plausible.js></script><meta property="og:title" content="Testing a Chrome Extension with Mocha and CoffeeScript"><meta property="og:description" content="So we&rsquo;ve previously seen how to bootstrap a chrome extension with CoffeeScript. The next step is about adding testing support. Even if it&rsquo;s a simple extension, the whole process of reloading the extension in the browser to manually test a feature is incredibly boring and error prone.
{% end_excerpt %}
To illustrate, TabSwitcher will be used as an example, more specifically the match(url, abbreviation) function which returns a float, indicating how close is abbreviation is to url."><meta property="og:type" content="article"><meta property="og:url" content="http://jhchabran.dev/posts/2012-11-28-testing-a-chrome-extension-with-mocha-and-coffeescript/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2012-11-28T00:00:00+00:00"><meta property="article:modified_time" content="2012-11-28T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Testing a Chrome Extension with Mocha and CoffeeScript"><meta name=twitter:description content="So we&rsquo;ve previously seen how to bootstrap a chrome extension with CoffeeScript. The next step is about adding testing support. Even if it&rsquo;s a simple extension, the whole process of reloading the extension in the browser to manually test a feature is incredibly boring and error prone.
{% end_excerpt %}
To illustrate, TabSwitcher will be used as an example, more specifically the match(url, abbreviation) function which returns a float, indicating how close is abbreviation is to url."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://jhchabran.dev/posts/"},{"@type":"ListItem","position":2,"name":"Testing a Chrome Extension with Mocha and CoffeeScript","item":"http://jhchabran.dev/posts/2012-11-28-testing-a-chrome-extension-with-mocha-and-coffeescript/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Testing a Chrome Extension with Mocha and CoffeeScript","name":"Testing a Chrome Extension with Mocha and CoffeeScript","description":"So we\u0026rsquo;ve previously seen how to bootstrap a chrome extension with CoffeeScript. The next step is about adding testing support. Even if it\u0026rsquo;s a simple extension, the whole process of reloading the extension in the browser to manually test a feature is incredibly boring and error prone.\n{% end_excerpt %}\nTo illustrate, TabSwitcher will be used as an example, more specifically the match(url, abbreviation) function which returns a float, indicating how close is abbreviation is to url.","keywords":["code"],"articleBody":"So we’ve previously seen how to bootstrap a chrome extension with CoffeeScript. The next step is about adding testing support. Even if it’s a simple extension, the whole process of reloading the extension in the browser to manually test a feature is incredibly boring and error prone.\n{% end_excerpt %}\nTo illustrate, TabSwitcher will be used as an example, more specifically the match(url, abbreviation) function which returns a float, indicating how close is abbreviation is to url.\nThis post assume you’re already comfortable with testing.\nSetuping the tests Before anything, a test framework needs to be chosen. Mocha is probably the most popular choice nowadays. It doesn’t come with an expectation library and defaults to NodeJS’s standard library : assert.\nAs you may know javascript Arrays being objects, testing equality between objects of the same type means testing identity. In short [1,2] == [1,2] evaluates to false. It does make sense given how the equality operator is defined yet being unusual to someone used to Ruby or Python.\nMost of the time, it’s equality between elements that is needed when writing assertions.\nA bad practice to achieve it would be to use toString(), converting them and running the comparison against the returned strings. It’s poor man’s equality because it would skip elements types, ie comparing [1,2] and ['1','2'] returns true instead of the expected false.\nNode’s assert library is obviously relying on the equality operator, it would yield false positives which are really painful to deal with.\nTo avoid wasting time plumbing with arrays comparisons, let’s just use an assertion library, Mocha advertises about should.js which provides our expected array comparison:\n{% highlight coffeescript %} it “should success”, - [1,2].should.eql([1,2]) {% endhighlight %}\nTo install these two libraries:\n{% highlight sh %} npm install mocha should -g {% endhighlight %}\nStoring tests under /tests directory is a no brainer. You can place that directory wherever you want, /spec being a common choice too.\n{% highlight sh %} cd tabswitcher # extension’s root dir mkdir tests {% endhighlight %}\nAnd create a file that will contain our tests. {% highlight sh %} touch spec/fuzzy_test.coffee {% endhighlight %}\n{% highlight coffeescript %} require ‘should’\ndescribe “Fuzzy”, - it “should fail”, - 0.should.eql(42) {% endhighlight %}\nRun it with {% highlight sh %} mocha –compilers coffee:coffee-script tests\n.\nX 1 of 1 test failed:\n  Fuzzy should fail: actual expected\n 42 0 at Object.Assertion.eql  (/home/tech/code/jhchabran/tabswitcher/node_modules/should/lib/should.js:285:10) at Context.(/home/tech/code/jhchabran/tabswitcher/tests/fuzzy_test.coffee:8:24) at Test.Runnable.run (/usr/local/lib/node_modules/mocha/lib/runnable.js:213:32) at Runner.runTest (/usr/local/lib/node_modules/mocha/lib/runner.js:341:10) at Runner.runTests.next (/usr/local/lib/node_modules/mocha/lib/runner.js:387:12) at next (/usr/local/lib/node_modules/mocha/lib/runner.js:267:14) at Runner.hooks (/usr/local/lib/node_modules/mocha/lib/runner.js:276:7) at next (/usr/local/lib/node_modules/mocha/lib/runner.js:224:23) at Runner.hook (/usr/local/lib/node_modules/mocha/lib/runner.js:244:5) at process.startup.processNextTick.process._tickCallback (node.js:244:9) {% endhighlight %}\n  A test task in the Cakefile comes handy to fire the tests.\nLoading the code we want to test Now tests are up and failing, it’s time to write expectations about functions that will be used in the extension. There is a last bump on our road to deal with. Code is ran in two different environments : browser and NodeJs.\nOn one hand, the chrome extension code runs in a browser, scripts are loaded by the html pages, through script tags. On the other hand tests run the code in a Node.js environment and loading is done through require and exports object.\nGiven src/fuzzy.coffee is going to define a match function we need to use in our tests, it first must be exported to be succesfully required afterward.\n{% highlight coffeescript %}\n/src/fuzzy.coffee match = (url, abbreviation)-\n… exports.match = match\n{% endhighlight %}\n{% highlight coffeescript %}\n/tests/fuzzy_spec.coffee f = require ‘../src/fuzzy’\ndescribe “Fuzzy”, - it “should call match”. - score = f.match “http://google.com”, “ggl” score.should.eql(3) {% endhighlight %}\nWe run it again with cake test and it should fail or success depending the implementation of match.\nBut if the extension is launched within the browser it will whine about exports not being defined. No surprise, in a browser context,exports doesn’t mean anything unless manually defined.\n{% highlight coffeescript %}\nIdiomatic predicate isCommonJS = typeof(window) == “undefined”\nif isCommonJS exports.match = match else window.match = match {% endhighlight %}\nAnd now we got our code both running in specs and in the extension.\nWhat about Chrome API ? Extension code that makes use of chrome.* apis that can’t be used in tests as is because they belong to Chrome and we’re running tests unde NodeJs.\nUsually simply separating concerns solves the problem. In the present case, match just returns a float, indicating how close the abbreviation is to the url. No api calls are made through computation, leaving no need to mock them in some sort.\nSometimes, for simplicity sake, it’s shorter to still pass around chrome api structures, like chrome.tab. Well, it’s just an object, build one that mimics the fields you need and that’s all.\n{% highlight coffeescript %}\n/tests/fuzzy_spec.coffee … tab = url : “http://google.com” title : “Google”\n… {% endhighlight %}\nIt’s coding time! We got our extension running CoffeeScript code and tests can be written as needed. Isn’t it more comfortable to write a Chrome Extension now ?\nAs we just added unit testing so far, an interesting question would be how to write some integration tests ? Like testing the whole workflow, considering we must deal with code running in different contexts: background page, popup and inserted in the current page.\nYou can find the example used through this post on Github.\n","wordCount":"890","inLanguage":"en","datePublished":"2012-11-28T00:00:00Z","dateModified":"2012-11-28T00:00:00Z","author":{"@type":"Person","name":"J.H. Chabran"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://jhchabran.dev/posts/2012-11-28-testing-a-chrome-extension-with-mocha-and-coffeescript/"},"publisher":{"@type":"Organization","name":"jhchabran","logo":{"@type":"ImageObject","url":"http://jhchabran.dev/favicon.ico"}}}</script></head><body id=top><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style></noscript><header class=header><nav class=nav><div class=logo><a href=http://jhchabran.dev/ accesskey=h title="jhchabran (Alt + H)">jhchabran</a>
<span class=logo-switches></span></div><ul id=menu><li><a href=http://jhchabran.dev/about/ title=about><span>about</span></a></li><li><a href=http://jhchabran.dev/posts/ title=posts><span>posts</span></a></li><li><a href=http://jhchabran.dev/categories/ title=categories><span>categories</span></a></li><li><a href=http://jhchabran.dev/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Testing a Chrome Extension with Mocha and CoffeeScript</h1><div class=post-meta>November 28, 2012&nbsp;·&nbsp;5 min&nbsp;·&nbsp;J.H. Chabran</div></header><div class=post-content><p>So we&rsquo;ve previously seen how to bootstrap <a href=http://jhchabran.com/blog/2011/12/17/build-a-chrome-extension-with-coffeescript/>a chrome extension with CoffeeScript</a>.
The next step is about adding testing support. Even if it&rsquo;s a simple
extension, the whole process of reloading the extension in the browser
to manually test a feature is incredibly boring and error prone.</p><p>{% end_excerpt %}</p><p>To illustrate,
<a href=https://chrome.google.com/webstore/detail/tabswitcher/gkdkligmcadfbagoeggeohelmgalchcn>TabSwitcher</a> will be used as an example, more
specifically the <code>match(url, abbreviation)</code> function which returns a <code>float</code>, indicating how close is
<code>abbreviation</code> is to <code>url</code>.</p><p>This post assume you&rsquo;re already comfortable with testing.</p><h2 id=setuping-the-tests>Setuping the tests<a hidden class=anchor aria-hidden=true href=#setuping-the-tests>#</a></h2><p>Before anything, a test framework needs to be chosen. Mocha is probably
the most popular choice nowadays. It doesn&rsquo;t come with an expectation
library and defaults to NodeJS&rsquo;s standard library :
<a href=http://nodejs.org/api/assert.html>assert</a>.</p><p>As you may know javascript Arrays being objects, testing equality between objects of the same type
means testing identity. In short <code>[1,2] == [1,2]</code> evaluates to <code>false</code>.
It does make sense given how the equality operator is defined yet being
unusual to someone used to Ruby or Python.</p><p>Most of the time, it&rsquo;s equality between elements that is needed when
writing assertions.</p><p>A bad practice to achieve it would be to use <code>toString()</code>, converting them and
running the comparison against the returned strings. It&rsquo;s poor man&rsquo;s
equality because it would skip elements types, ie comparing <code>[1,2]</code>
and <code>['1','2']</code> returns <code>true</code> instead of the expected <code>false</code>.</p><p>Node&rsquo;s assert library is obviously relying on the equality operator, it
would yield false positives which are really painful to deal with.</p><p>To avoid wasting time plumbing with arrays comparisons, let&rsquo;s just use
an assertion library, Mocha advertises about should.js which provides
our expected array comparison:</p><p>{% highlight coffeescript %}
it &ldquo;should success&rdquo;, ->
[1,2].should.eql([1,2])
{% endhighlight %}</p><p>To install these two libraries:</p><p>{% highlight sh %}
npm install mocha should -g
{% endhighlight %}</p><p>Storing tests under <code>/tests</code> directory is a no brainer. You can place
that directory wherever you want, <code>/spec</code> being a common choice
too.</p><p>{% highlight sh %}
cd tabswitcher # extension&rsquo;s root dir
mkdir tests
{% endhighlight %}</p><p>And create a file that will contain our tests.
{% highlight sh %}
touch spec/fuzzy_test.coffee
{% endhighlight %}</p><p>{% highlight coffeescript %}
require &lsquo;should&rsquo;</p><p>describe &ldquo;Fuzzy&rdquo;, ->
it &ldquo;should fail&rdquo;, ->
0.should.eql(42)
{% endhighlight %}</p><p>Run it with
{% highlight sh %}
mocha &ndash;compilers coffee:coffee-script tests</p><p>.</p><p>X 1 of 1 test failed:</p><ol><li><p>Fuzzy should fail:
actual expected</p><pre><code>  42 0

  at Object.Assertion.eql
</code></pre><p>(/home/tech/code/jhchabran/tabswitcher/node_modules/should/lib/should.js:285:10)
at Context.
(/home/tech/code/jhchabran/tabswitcher/tests/fuzzy_test.coffee:8:24)
at Test.Runnable.run
(/usr/local/lib/node_modules/mocha/lib/runnable.js:213:32)
at Runner.runTest
(/usr/local/lib/node_modules/mocha/lib/runner.js:341:10)
at Runner.runTests.next
(/usr/local/lib/node_modules/mocha/lib/runner.js:387:12)
at next (/usr/local/lib/node_modules/mocha/lib/runner.js:267:14)
at Runner.hooks
(/usr/local/lib/node_modules/mocha/lib/runner.js:276:7)
at next (/usr/local/lib/node_modules/mocha/lib/runner.js:224:23)
at Runner.hook
(/usr/local/lib/node_modules/mocha/lib/runner.js:244:5)
at process.startup.processNextTick.process._tickCallback
(node.js:244:9)
{% endhighlight %}</p></li></ol><p>A <a href=https://github.com/jhchabran/tabswitcher/blob/master/Cakefile#L46>test
task</a> in the Cakefile comes handy to fire the tests.</p><h2 id=loading-the-code-we-want-to-test>Loading the code we want to test<a hidden class=anchor aria-hidden=true href=#loading-the-code-we-want-to-test>#</a></h2><p>Now tests are up and failing, it&rsquo;s time to write expectations about
functions that will be used in the extension. There is a last bump on
our road to deal with. Code is ran in two different environments :
browser and NodeJs.</p><p>On one hand, the chrome extension code runs in a browser, scripts are loaded by the html
pages, through <code>script</code> tags. On the other hand tests
run the code in a Node.js environment and loading is done through
<code>require</code> and <code>exports</code> object.</p><p>Given <code>src/fuzzy.coffee</code> is going to define a <code>match</code> function
we need to use in our tests, it first must be exported to be succesfully required
afterward.</p><p>{% highlight coffeescript %}</p><h1 id=srcfuzzycoffee>/src/fuzzy.coffee<a hidden class=anchor aria-hidden=true href=#srcfuzzycoffee>#</a></h1><p>match = (url, abbreviation)-></p><h1 id=heading>&mldr;<a hidden class=anchor aria-hidden=true href=#heading>#</a></h1><p>exports.match = match<br>{% endhighlight %}</p><p>{% highlight coffeescript %}</p><h1 id=testsfuzzy_speccoffee>/tests/fuzzy_spec.coffee<a hidden class=anchor aria-hidden=true href=#testsfuzzy_speccoffee>#</a></h1><p>f = require &lsquo;../src/fuzzy&rsquo;</p><p>describe &ldquo;Fuzzy&rdquo;, ->
it &ldquo;should call match&rdquo;. ->
score = f.match &ldquo;<a href=http://google.com>http://google.com</a>&rdquo;, &ldquo;ggl&rdquo;
score.should.eql(3)
{% endhighlight %}</p><p>We run it again with <code>cake test</code> and it should fail or success
depending the implementation of <code>match</code>.</p><p>But if the extension is launched within the browser it will whine about
<code>exports</code> not being defined. No surprise, in a browser
context,<code>exports</code> doesn&rsquo;t mean anything unless manually defined.</p><p>{% highlight coffeescript %}</p><h1 id=idiomatic-predicate>Idiomatic predicate<a hidden class=anchor aria-hidden=true href=#idiomatic-predicate>#</a></h1><p>isCommonJS = typeof(window) == &ldquo;undefined&rdquo;</p><p>if isCommonJS
exports.match = match
else
window.match = match
{% endhighlight %}</p><p>And now we got our code both running in specs and in the extension.</p><h2 id=what-about-chrome-api->What about Chrome API ?<a hidden class=anchor aria-hidden=true href=#what-about-chrome-api->#</a></h2><p>Extension code that makes use of chrome.* apis that can&rsquo;t be used in tests as is because they belong to Chrome and we&rsquo;re running tests unde NodeJs.</p><p>Usually simply separating concerns solves the problem. In the
present case, <code>match</code> just returns a float, indicating how close the
abbreviation is to the url. No api calls are made through computation,
leaving no need to mock them in some sort.</p><p>Sometimes, for simplicity sake, it&rsquo;s shorter to still pass around chrome
api structures, like <code>chrome.tab</code>. Well, it&rsquo;s just an object, build
one that mimics the fields you need and that&rsquo;s all.</p><p>{% highlight coffeescript %}</p><h1 id=testsfuzzy_speccoffee-1>/tests/fuzzy_spec.coffee<a hidden class=anchor aria-hidden=true href=#testsfuzzy_speccoffee-1>#</a></h1><h1 id=heading-1>&mldr;<a hidden class=anchor aria-hidden=true href=#heading-1>#</a></h1><p>tab =
url : &ldquo;<a href=http://google.com>http://google.com</a>&rdquo;
title : &ldquo;Google&rdquo;</p><h1 id=heading-2>&mldr;<a hidden class=anchor aria-hidden=true href=#heading-2>#</a></h1><p>{% endhighlight %}</p><h2 id=its-coding-time>It&rsquo;s coding time!<a hidden class=anchor aria-hidden=true href=#its-coding-time>#</a></h2><p>We got our extension running CoffeeScript code and tests can be written as
needed. Isn&rsquo;t it more comfortable to write a Chrome Extension now ?</p><p>As we just added unit testing so far, an interesting question would be how to write some integration tests ? Like testing the whole workflow, considering we must deal with code running in different contexts: background page, popup and inserted in the current page.</p><p>You can find the <a href=http://github.com/jhchabran/TabSwitcher>example used through this post on Github</a>.</p></div><footer class=post-footer><ul class=post-tags><li><a href=http://jhchabran.dev/tags/code/>code</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2021 <a href=http://jhchabran.dev/>jhchabran</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script></body></html>