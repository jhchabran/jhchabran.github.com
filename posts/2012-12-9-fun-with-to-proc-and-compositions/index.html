<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Fun with to_proc and compositions | jhchabran</title><meta name=keywords content="code"><meta name=description content="What about being able to shorten users.collect { |user| user.order.city } or its unefficient form users.collect(&:order).collect(&:city) into
{% highlight ruby %} users.collect(&[:order, :city]) {% endhighlight %}
It can be achieved by composing functions, in Ruby&rsquo;s case by composing Procs. This is an amusing exercise that demonstrates Ruby&rsquo;s functional abilites.
{% end_excerpt %}
Just in case you need to freshen your memory about composing functions, it&rsquo;s a common notion in functional programming and it&rsquo;s also found early in mathematics courses."><meta name=author content="J.H. Chabran"><link rel=canonical href=http://jhchabran.dev/posts/2012-12-9-fun-with-to-proc-and-compositions/><link crossorigin=anonymous href=/assets/css/stylesheet.min.cc99f8f13de8919e292c4e3d755d41b89cbd30ecf7d2c9537fdeb25a6c2a9544.css integrity="sha256-zJn48T3okZ4pLE49dV1BuJy9MOz30slTf96yWmwqlUQ=" rel="preload stylesheet" as=style><link rel=preload href=./avatar.jpg as=image><script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=http://jhchabran.dev/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://jhchabran.dev/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://jhchabran.dev/favicon-32x32.png><link rel=apple-touch-icon href=http://jhchabran.dev/apple-touch-icon.png><link rel=mask-icon href=http://jhchabran.dev/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.82.0"><link rel=stylesheet href=https://use.typekit.net/pmg0uoe.css><script async defer data-domain=jhchabran.dev src=https://plausible.io/js/plausible.js></script><meta property="og:title" content="Fun with to_proc and compositions"><meta property="og:description" content="What about being able to shorten users.collect { |user| user.order.city } or its unefficient form users.collect(&:order).collect(&:city) into
{% highlight ruby %} users.collect(&[:order, :city]) {% endhighlight %}
It can be achieved by composing functions, in Ruby&rsquo;s case by composing Procs. This is an amusing exercise that demonstrates Ruby&rsquo;s functional abilites.
{% end_excerpt %}
Just in case you need to freshen your memory about composing functions, it&rsquo;s a common notion in functional programming and it&rsquo;s also found early in mathematics courses."><meta property="og:type" content="article"><meta property="og:url" content="http://jhchabran.dev/posts/2012-12-9-fun-with-to-proc-and-compositions/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2012-12-09T00:00:00+00:00"><meta property="article:modified_time" content="2012-12-09T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Fun with to_proc and compositions"><meta name=twitter:description content="What about being able to shorten users.collect { |user| user.order.city } or its unefficient form users.collect(&:order).collect(&:city) into
{% highlight ruby %} users.collect(&[:order, :city]) {% endhighlight %}
It can be achieved by composing functions, in Ruby&rsquo;s case by composing Procs. This is an amusing exercise that demonstrates Ruby&rsquo;s functional abilites.
{% end_excerpt %}
Just in case you need to freshen your memory about composing functions, it&rsquo;s a common notion in functional programming and it&rsquo;s also found early in mathematics courses."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://jhchabran.dev/posts/"},{"@type":"ListItem","position":2,"name":"Fun with to_proc and compositions","item":"http://jhchabran.dev/posts/2012-12-9-fun-with-to-proc-and-compositions/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Fun with to_proc and compositions","name":"Fun with to_proc and compositions","description":"What about being able to shorten users.collect { |user| user.order.city } or its unefficient form users.collect(\u0026amp;:order).collect(\u0026amp;:city) into\n{% highlight ruby %} users.collect(\u0026amp;[:order, :city]) {% endhighlight %}\nIt can be achieved by composing functions, in Ruby\u0026rsquo;s case by composing Procs. This is an amusing exercise that demonstrates Ruby\u0026rsquo;s functional abilites.\n{% end_excerpt %}\nJust in case you need to freshen your memory about composing functions, it\u0026rsquo;s a common notion in functional programming and it\u0026rsquo;s also found early in mathematics courses.","keywords":["code"],"articleBody":"What about being able to shorten users.collect { |user| user.order.city } or its unefficient form users.collect(\u0026:order).collect(\u0026:city) into\n{% highlight ruby %} users.collect(\u0026[:order, :city]) {% endhighlight %}\nIt can be achieved by composing functions, in Ruby’s case by composing Procs. This is an amusing exercise that demonstrates Ruby’s functional abilites.\n{% end_excerpt %}\nJust in case you need to freshen your memory about composing functions, it’s a common notion in functional programming and it’s also found early in mathematics courses.\nGiven two functions f(x) and g(x), (g o f)(x) == g(f(x)), o being the symbol of the composition operation.\nUnchaining method calls users.collect { |user| user.order.city }\nThe first step here is to compact the #order and #city method calls.\nTo achieve that, it’s interesting to know how methods calls are done under the hood. Python, by being explicit by design as opposed to Ruby, gives a clear answer :\n{% highlight python %} class User def init(self, firstname, lastname): self.firstname = firstname self.lastname = lastname\ndef name(self): return self.firstname + self.lastname {% endhighlight %}\nEach method accepts a first argument which is always self. It’s simple as that, a method is nothing more than a function whose first argument is the instance. This way, attributes can be accessed trough self inside the function. Under the hood in Ruby @firstname is basically just a nice way to grab it from the instance without having to be explicit about self.\nBack to our example, with that knowledge we can say that :\n{% highlight ruby %} users.collect { |user| user.order.city } {% endhighlight %}\nis equivalent in the underlying implementation to :\n{% highlight ruby %}\npseudo-code users.collect { |user| city(order(user)) } {% endhighlight %}\nSo that’s it, in theory we got functions here and composing them makes sense :\n{% highlight ruby %}\npseudo-code, ‘o’ being the hypothetical composition operator. get_order_then_city = city o order users.collect { |user| get_order_then_city(user) } {% endhighlight %}\nFinally, let’s convert that to real Ruby code, artificially reverting methods to their primitive forms, functions.\n{% highlight ruby %} order = Proc.new { |user| user.order } city = Proc.new { |order| order.city } {% endhighlight %}\nThose two Procs still need to be composed, sadly Ruby don’t come with a defined composition operator for Proc, so let’s write one.\nComposing functions in Ruby As Procs are Ruby objects, it’s simply a matter of adding a composition operator to the Proc class. As the symbol used in mathematics, o can’t be used here, it’s usually * that takes its place.\n{% highlight ruby %} increment = Proc.new { |x| x + 1 } square = Proc.new { |x| x * x }\nincrement_and_square = square * increment\np increment_and_square(2)\n= (2+1)^2 = 9 {% endhighlight %}\nImplementation is pretty straight-forward :\n{% highlight ruby %} class Proc def *(other) Proc.new { |x| call(other.call(x)) } end end {% endhighlight %}\nNow increment and square can be composed throught the * operator and it works as expected.\nBack to business At this point, the job is almost finished. Procs can be composed, and symbols can be converted to Procs thanks to \u0026:order.\n\u0026:order is quite common but before composing it, how does it really works ?\nBehind its somewhat exotic syntax, it calls #to_proc which creates a Proc that sends the symbol itself, (:order in this case) to an object. Then it converts the Proc into a block so it can be passed to methods like #each or #collect that expects one.\nIn more concrete terms \u0026:order creates the following Proc:\n{% highlight ruby %} get_order = Proc.new { |user| user.order } {% endhighlight %}\nAnd its generalized form:\n{% highlight ruby %} class Symbol def to_proc # This is a simplified version, the real one can handle multiple # arguments. Proc.new { |object| object.send(self) } end end\n{% endhighlight %}\nSuch Procs can as previously seen, be easily composed with the brand new * operator on Procs.\nAt this point it can be tempting to write users.collect(\u0026:city * \u0026:order) but this can’t work. As a block isn’t an object, calling any method on it (#* in this case) makes absolutely no sense. Only a single unary \u0026 can exist in an expression. Ruby will raise a SyntaxError if a second one is present.\nThe correct syntax with a single \u0026 isn’t really shiny, but it works as expected.\n{% highlight ruby %} users.collect(\u0026(:city.to_proc * :order.to_proc))\n= [‘Kuala Lumpur’, ‘Paris’] {% endhighlight %}\nBut frankly, from a syntactic point of view, it’s sill far from being simpler than a traditional users.collect { |user| user.order.city } and the order feels a bit backward.\nAdding Syntactic Sugar Even if it’s just for fun, better syntax can be achived by calling Array to the rescue. Having a list of Procs that will be composed makes some sense and provides a lighter syntax.\n{% highlight ruby %} users.collect(\u0026[:city, :order])\n= [‘Kuala Lumpur’, ‘Paris’] {% endhighlight %}\n#to_proc can be added to basically any object, while this opens many weird and exotic possibilites it suits perfectly what is needed here.\nSo building a Proc from an array of symbols, given they can be converted to procs and then composed, can be written as the following:\n{% highlight ruby %} class array def to_proc collect(\u0026:to_proc).inject(\u0026:*) end end\nusers.collect(\u0026[:city, :order])\n= [‘kuala lumpur’, ‘paris’] {% endhighlight %}\nYet without knowing we’re composing stuff under the hood, it would be nice to have the symbols ordered like the chained method calls.\n{% highlight ruby %} class array def to_proc reverse.collect(\u0026:to_proc).inject(\u0026:*) end end\nusers.collect(\u0026[:order, :city])\n= [‘kuala lumpur’, ‘paris’] {% endhighlight %}\nAnd it does the job and with a nice syntax!\nThe only bad thing here is it has to create a Proc for each symbol and that’s why nobody should use it in real code. A less fun but more practical version can be written by using #inject and #send:\n{% highlight ruby %} class Array def to_proc Proc.new do |object| inject(object) do |this, method_id| this.send(method_id) end end end end {% endhighlight %}\n","wordCount":"1006","inLanguage":"en","datePublished":"2012-12-09T00:00:00Z","dateModified":"2012-12-09T00:00:00Z","author":{"@type":"Person","name":"J.H. Chabran"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://jhchabran.dev/posts/2012-12-9-fun-with-to-proc-and-compositions/"},"publisher":{"@type":"Organization","name":"jhchabran","logo":{"@type":"ImageObject","url":"http://jhchabran.dev/favicon.ico"}}}</script></head><body id=top><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style></noscript><header class=header><nav class=nav><div class=logo><a href=http://jhchabran.dev/ accesskey=h title="jhchabran (Alt + H)">jhchabran</a>
<span class=logo-switches></span></div><ul id=menu><li><a href=http://jhchabran.dev/about/ title=about><span>about</span></a></li><li><a href=http://jhchabran.dev/posts/ title=posts><span>posts</span></a></li><li><a href=http://jhchabran.dev/categories/ title=categories><span>categories</span></a></li><li><a href=http://jhchabran.dev/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Fun with to_proc and compositions</h1><div class=post-meta>December 9, 2012&nbsp;·&nbsp;5 min&nbsp;·&nbsp;J.H. Chabran</div></header><div class=post-content><p>What about being able to shorten <code>users.collect { |user| user.order.city }</code> or its
unefficient form <code>users.collect(&:order).collect(&:city)</code> into</p><p>{% highlight ruby %}
users.collect(&[:order, :city])
{% endhighlight %}</p><p>It can be achieved by composing functions, in Ruby&rsquo;s case by composing Procs.
This is an amusing exercise that demonstrates Ruby&rsquo;s functional abilites.</p><p>{% end_excerpt %}</p><p>Just in case you need to freshen your memory about composing functions, it&rsquo;s a common notion in functional programming and it&rsquo;s also found early in mathematics courses.</p><p>Given two functions <code>f(x)</code> and <code>g(x)</code>, <code>(g o f)(x) == g(f(x))</code>, <code>o</code> being the symbol of the composition operation.</p><h2 id=unchaining-method-calls>Unchaining method calls<a hidden class=anchor aria-hidden=true href=#unchaining-method-calls>#</a></h2><p><code>users.collect { |user| user.order.city }</code></p><p>The first step here is to compact the <code>#order</code> and <code>#city</code> method calls.</p><p>To achieve that, it&rsquo;s interesting to know how methods calls are done
under the hood. Python, by being explicit by design as opposed to Ruby, gives a clear
answer :</p><p>{% highlight python %}
class User
def <strong>init</strong>(self, firstname, lastname):
self.firstname = firstname
self.lastname = lastname</p><p>def name(self):
return self.firstname + self.lastname
{% endhighlight %}</p><p>Each method accepts a first argument which is always <code>self</code>.
It&rsquo;s simple as that, a method is nothing more than a function
whose first argument is the instance. This way, attributes can be
accessed trough self inside the function. Under the hood in Ruby <code>@firstname</code> is basically just a nice way to grab it from the instance without having to be explicit about <code>self</code>.</p><p>Back to our example, with that knowledge we can say that :</p><p>{% highlight ruby %}
users.collect { |user| user.order.city }
{% endhighlight %}</p><p>is equivalent in the underlying implementation to :</p><p>{% highlight ruby %}</p><h1 id=pseudo-code>pseudo-code<a hidden class=anchor aria-hidden=true href=#pseudo-code>#</a></h1><p>users.collect { |user| city(order(user)) }
{% endhighlight %}</p><p>So that&rsquo;s it, in theory we got functions here and composing them makes
sense :</p><p>{% highlight ruby %}</p><h1 id=pseudo-code-o-being-the-hypothetical-composition-operator>pseudo-code, &lsquo;o&rsquo; being the hypothetical composition operator.<a hidden class=anchor aria-hidden=true href=#pseudo-code-o-being-the-hypothetical-composition-operator>#</a></h1><p>get_order_then_city = city o order
users.collect { |user| get_order_then_city(user) }
{% endhighlight %}</p><p>Finally, let&rsquo;s convert that to real Ruby code, artificially reverting methods to
their primitive forms, functions.</p><p>{% highlight ruby %}
order = Proc.new { |user| user.order }
city = Proc.new { |order| order.city }
{% endhighlight %}</p><p>Those two Procs still need to be composed, sadly Ruby don&rsquo;t come with a
defined composition operator for Proc, so let&rsquo;s write one.</p><h2 id=composing-functions-in-ruby>Composing functions in Ruby<a hidden class=anchor aria-hidden=true href=#composing-functions-in-ruby>#</a></h2><p>As Procs are Ruby objects, it&rsquo;s simply a matter of adding a composition
operator to the Proc class. As the symbol used in mathematics, <code>o</code> can&rsquo;t be used here,
it&rsquo;s usually <code>*</code> that takes its place.</p><p>{% highlight ruby %}
increment = Proc.new { |x| x + 1 }
square = Proc.new { |x| x * x }</p><p>increment_and_square = square * increment</p><p>p increment_and_square(2)</p><h1 id=-212--9>=> (2+1)^2 = 9<a hidden class=anchor aria-hidden=true href=#-212--9>#</a></h1><p>{% endhighlight %}</p><p>Implementation is pretty straight-forward :</p><p>{% highlight ruby %}
class Proc
def *(other)
Proc.new { |x| call(other.call(x)) }
end
end
{% endhighlight %}</p><p>Now <code>increment</code> and <code>square</code> can be composed throught the
<code>*</code>
operator and it works as expected.</p><h2 id=back-to-business>Back to business<a hidden class=anchor aria-hidden=true href=#back-to-business>#</a></h2><p>At this point, the job is almost finished. Procs can be composed,
and symbols can be converted to Procs thanks to <code>&:order</code>.</p><p><code>&:order</code> is quite common but before composing it, how does it really works ?</p><p>Behind its somewhat exotic syntax, it calls <code>#to_proc</code> which creates a Proc that sends the
symbol itself, (<code>:order</code> in this case) to an object. Then it
converts the Proc into a block so it can be passed to methods like
<code>#each</code> or <code>#collect</code> that expects one.</p><p>In more concrete terms <code>&:order</code> creates the following Proc:</p><p>{% highlight ruby %}
get_order = Proc.new { |user| user.order }
{% endhighlight %}</p><p>And its generalized form:</p><p>{% highlight ruby %}
class Symbol
def to_proc # This is a simplified version, the real one can handle multiple # arguments.
Proc.new { |object| object.<strong>send</strong>(self) }
end
end</p><p>{% endhighlight %}</p><p>Such Procs can as previously seen, be easily composed with the brand new <code>*</code>
operator on Procs.</p><p>At this point it can be tempting to write <code>users.collect(&:city * &:order)</code> but
this can&rsquo;t work. As a block isn&rsquo;t an object, calling any method on it (<code>#*</code> in this case) makes absolutely no sense.
Only a single unary <code>&</code> can exist in an expression. Ruby will raise a <code>SyntaxError</code> if
a second one is present.</p><p>The correct syntax with a single <code>&</code> isn&rsquo;t really shiny, but it
works as expected.</p><p>{% highlight ruby %}
users.collect(&(:city.to_proc * :order.to_proc))</p><h1 id=-kuala-lumpur-paris>=> [&lsquo;Kuala Lumpur&rsquo;, &lsquo;Paris&rsquo;]<a hidden class=anchor aria-hidden=true href=#-kuala-lumpur-paris>#</a></h1><p>{% endhighlight %}</p><p>But frankly, from a syntactic point of view, it&rsquo;s sill far from being simpler
than a traditional <code>users.collect { |user| user.order.city }</code> and
the order feels a bit backward.</p><h2 id=adding-syntactic-sugar>Adding Syntactic Sugar<a hidden class=anchor aria-hidden=true href=#adding-syntactic-sugar>#</a></h2><p>Even if it&rsquo;s just for fun, better syntax can be achived by calling
Array to the rescue. Having a list of Procs that will be composed makes some sense and provides a lighter syntax.</p><p>{% highlight ruby %}
users.collect(&[:city, :order])</p><h1 id=-kuala-lumpur-paris-1>=> [&lsquo;Kuala Lumpur&rsquo;, &lsquo;Paris&rsquo;]<a hidden class=anchor aria-hidden=true href=#-kuala-lumpur-paris-1>#</a></h1><p>{% endhighlight %}</p><p><code>#to_proc</code> can be added to basically any object, while this opens
many weird and exotic possibilites it suits perfectly what is needed
here.</p><p>So building a Proc from an array of symbols, given they can be converted
to procs and then composed, can be written as the following:</p><p>{% highlight ruby %}
class array
def to_proc
collect(&:to_proc).inject(&:*)
end
end</p><p>users.collect(&[:city, :order])</p><h1 id=-kuala-lumpur-paris-2>=> [&lsquo;kuala lumpur&rsquo;, &lsquo;paris&rsquo;]<a hidden class=anchor aria-hidden=true href=#-kuala-lumpur-paris-2>#</a></h1><p>{% endhighlight %}</p><p>Yet without knowing we&rsquo;re composing stuff under the hood, it would be
nice to have the symbols ordered like the chained method calls.</p><p>{% highlight ruby %}
class array
def to_proc
reverse.collect(&:to_proc).inject(&:*)
end
end</p><p>users.collect(&[:order, :city])</p><h1 id=-kuala-lumpur-paris-3>=> [&lsquo;kuala lumpur&rsquo;, &lsquo;paris&rsquo;]<a hidden class=anchor aria-hidden=true href=#-kuala-lumpur-paris-3>#</a></h1><p>{% endhighlight %}</p><p>And it does the job and with a nice syntax!</p><p>The only bad thing here is it has to create a Proc for each symbol and that&rsquo;s why nobody should use it in real code. A less fun but more practical version can be written by using
<code>#inject</code> and <code>#send</code>:</p><p>{% highlight ruby %}
class Array
def to_proc
Proc.new do |object|
inject(object) do |this, method_id|
this.send(method_id)
end
end
end
end
{% endhighlight %}</p></div><footer class=post-footer><ul class=post-tags><li><a href=http://jhchabran.dev/tags/code/>code</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2021 <a href=http://jhchabran.dev/>jhchabran</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script></body></html>