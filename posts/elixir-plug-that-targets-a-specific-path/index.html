<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>An Elixir Plug that targets a specific path | jhchabran</title><meta name=keywords content="code"><meta name=description content="I originally published this post on Heetch Engineering and has been ported here for archiving purposes.
  Plug is a cornerstone of Elixir and handling HTTP requests. It’s striking how simple it is to write one:
defmodule Example.HelloWorldPlug do import Plug.Conn def init(options), do: options def call(conn, _opts) do conn |> put_resp_content_type(&#34;text/plain&#34;) |> send_resp(200, &#34;Hello World!\n&#34;) end end Yet simple does not necessarily mean that it is easy to use, especially when you’re getting started."><meta name=author content="J.H. Chabran"><link rel=canonical href=http://jhchabran.dev/posts/elixir-plug-that-targets-a-specific-path/><link crossorigin=anonymous href=/assets/css/stylesheet.min.a65a27fc4e81a2b15f42bbf617e1f4082b6ac47d3a90dd059a1ceaa73557b31b.css integrity="sha256-plon/E6BorFfQrv2F+H0CCtqxH06kN0FmhzqpzVXsxs=" rel="preload stylesheet" as=style><link rel=preload href=./avatar.jpg as=image><script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=http://jhchabran.dev/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://jhchabran.dev/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://jhchabran.dev/favicon-32x32.png><link rel=apple-touch-icon href=http://jhchabran.dev/apple-touch-icon.png><link rel=mask-icon href=http://jhchabran.dev/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.82.0"><link rel=stylesheet href=https://use.typekit.net/pmg0uoe.css><script async defer data-domain=jhchabran.dev src=https://plausible.io/js/plausible.js></script><meta property="og:title" content="An Elixir Plug that targets a specific path"><meta property="og:description" content="I originally published this post on Heetch Engineering and has been ported here for archiving purposes.
  Plug is a cornerstone of Elixir and handling HTTP requests. It’s striking how simple it is to write one:
defmodule Example.HelloWorldPlug do import Plug.Conn def init(options), do: options def call(conn, _opts) do conn |> put_resp_content_type(&#34;text/plain&#34;) |> send_resp(200, &#34;Hello World!\n&#34;) end end Yet simple does not necessarily mean that it is easy to use, especially when you’re getting started."><meta property="og:type" content="article"><meta property="og:url" content="http://jhchabran.dev/posts/elixir-plug-that-targets-a-specific-path/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-03-29T00:00:00+00:00"><meta property="article:modified_time" content="2018-03-29T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="An Elixir Plug that targets a specific path"><meta name=twitter:description content="I originally published this post on Heetch Engineering and has been ported here for archiving purposes.
  Plug is a cornerstone of Elixir and handling HTTP requests. It’s striking how simple it is to write one:
defmodule Example.HelloWorldPlug do import Plug.Conn def init(options), do: options def call(conn, _opts) do conn |> put_resp_content_type(&#34;text/plain&#34;) |> send_resp(200, &#34;Hello World!\n&#34;) end end Yet simple does not necessarily mean that it is easy to use, especially when you’re getting started."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://jhchabran.dev/posts/"},{"@type":"ListItem","position":2,"name":"An Elixir Plug that targets a specific path","item":"http://jhchabran.dev/posts/elixir-plug-that-targets-a-specific-path/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"An Elixir Plug that targets a specific path","name":"An Elixir Plug that targets a specific path","description":"I originally published this post on Heetch Engineering and has been ported here for archiving purposes.\n  Plug is a cornerstone of Elixir and handling HTTP requests. It’s striking how simple it is to write one:\ndefmodule Example.HelloWorldPlug do import Plug.Conn def init(options), do: options def call(conn, _opts) do conn |\u0026gt; put_resp_content_type(\u0026#34;text/plain\u0026#34;) |\u0026gt; send_resp(200, \u0026#34;Hello World!\\n\u0026#34;) end end Yet simple does not necessarily mean that it is easy to use, especially when you’re getting started.","keywords":["code"],"articleBody":"I originally published this post on Heetch Engineering and has been ported here for archiving purposes.\n  Plug is a cornerstone of Elixir and handling HTTP requests. It’s striking how simple it is to write one:\ndefmodule Example.HelloWorldPlug do import Plug.Conn def init(options), do: options def call(conn, _opts) do conn | put_resp_content_type(\"text/plain\") | send_resp(200, \"Hello World!\\n\") end end Yet simple does not necessarily mean that it is easy to use, especially when you’re getting started.\nFor example, if you look at the code above, it’s not obvious how to update it so it only acts on a specific path. That’s precisely what we’ll be looking at here.\nA concrete example An example of such a feature could be a health check handler. It’s an HTTP route (ex: /_health_check) that can be requested to know if a given web application is performing correctly or not.\n A 200 OK status code means that yes, it’s operating properly. Anything else would mean that there is a problem and this instance of our application should not receive requests anymore.  This way clients have a way to know if it’s running smoothly or not. For example, container orchestration solutions such as Kubernetes and Mesosphere DC/OS use this mechanism to know if it should kill Docker container running the app or not.\nWe will be using this use case during the rest of this post.\nWhy not just use Plug.Router? If all we want is to match on a given path and respond with a specific response, Plug.Router sounds like an immediate solution. But what if we need to share the health check code among Phoenix apps and other Plug-based apps ?\nA module using Plug.Router is a plug itself and thus could be shared. But can’t we just write a bare plug instead for the sake of simplicity?\nLet’s see where we start if we’re not using Plug.Router to match specific routes. For a module to be a plug, it needs the call/2 callback to be implemented.\ncall/2 takes two parameters, conn which is a %Plug.Conn{}, representing our connection to the client and opts, a set of options.\nLooking at what is inside the %Plug.Conn{} struct, we can see that there are many interesting fields:\n# (straight from https://github.com/elixir-plug/plug/blob/578cd973037bd3e8695817a0c4c69cac9d22db6a/lib/plug/conn.ex#L17-L32) defmodule Plug.Conn do @moduledoc \"\"\" (...) ##Request fields * (...) * `host` - the requested host as a binary, example: `\"www.example.com\"` * `method` - the request method as a binary, example: `\"GET\" * `request_path` - the requested path, example: `/trailing/and//double//slashes/` * `path_info` - the path split into segments, example: `[\"hello\", \"world\"] * `query_string` - the request query string as a binary, example: `\"foo=bar\"` * (...) (...) \"\"\" end All these attributes being inside conn, we can pattern match against them. request_path is a good fit but it may contain trailing slashes. Instead, path_info is a list of each segment in the path, so we don’t have to bother with slashes at all, making it a better choice here.\nLet’s see how it goes:\ndefmodule HealthCheck.Plug do import Plug.Conn @behaviour Plug def init(opts), do: opts # path_info matches with health check path! def call(conn = %{path_info: [\"_health_check\"]}, _opts) do conn | send_resp(200, \"ok\") | halt() end # nope, not for us, pass it down the chain. def call(conn, _opts), do: conn end So, in concrete terms, given that the health check path is /_health_check:\n If path_infomatches, respond with a 200 status code and halt the plug pipeline so that no other plugs will be called. Otherwise, just pass the request down the chain to other plugs, like plug :match from Plug.Router or Phoenix.Router.  Using our plug with Plug.Router The HealthCheck.Plug can be used like any other plug but, if we want to use it within a Plug.Router, where it is inserted can change the outcome. Inserting it after plug :dispatch and plug :match will lead to the request being caught by the catch-all route before reaching our plug.\nSo the right way to use it is as follows:\ndefmodule MyApp.Router do use Plug.Router # This plug must be included **before** `plug :dispatch` and `plug :match`. # Otherwise, the reponse will already be sent before it reaches the HealthCheck Plug. plug HealthCheck.Plug plug :match plug :dispatch match _ do send_resp(conn, 404, \"not found\") end end Using our plug with Phoenix Phoenix works similarly. The plug needs to be inserted before any routing happens. Without diving into details, Phoenix implements its HTTP handler in two components, the endpoint which is a top-level plug and the router, where routes are defined.\nSo here, it’s required to insert our Plug in the endpoint, before inserting the router (exactly like we’ve seen previously).\ndefmodule MyAppWeb.Endpoint do use Phoenix.Endpoint, otp_app: :my_app # This plug must absolutely be included **before** `plug MyAppWeb.Router` plug HealthCheck.Plug plug MyAppWeb.Router end Conclusion All that was done in here was to inspect what’s inside a connand pattern match against it. Very often, pattern matching is itself powerful enough to solve most problems.\nIn the end and like in other functional languages, looking at what structures are being carried around is really helpful and provides a lot of insight. It should be one of the first things to inspect when exploring code.\n","wordCount":"861","inLanguage":"en","datePublished":"2018-03-29T00:00:00Z","dateModified":"2018-03-29T00:00:00Z","author":{"@type":"Person","name":"J.H. Chabran"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://jhchabran.dev/posts/elixir-plug-that-targets-a-specific-path/"},"publisher":{"@type":"Organization","name":"jhchabran","logo":{"@type":"ImageObject","url":"http://jhchabran.dev/favicon.ico"}}}</script></head><body id=top><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style></noscript><header class=header><nav class=nav><div class=logo><a href=http://jhchabran.dev/ accesskey=h title="jhchabran (Alt + H)">jhchabran</a>
<span class=logo-switches></span></div><ul id=menu><li><a href=http://jhchabran.dev/about/ title=about><span>about</span></a></li><li><a href=http://jhchabran.dev/posts/ title=posts><span>posts</span></a></li><li><a href=http://jhchabran.dev/categories/ title=categories><span>categories</span></a></li><li><a href=http://jhchabran.dev/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>An Elixir Plug that targets a specific path</h1><div class=post-meta>March 29, 2018&nbsp;·&nbsp;5 min&nbsp;·&nbsp;J.H. Chabran</div></header><div class=post-content><p><em>I originally published this post on <a href=https://medium.com/inside-heetch/an-elixir-plug-that-targets-a-specific-path-f0c17bd232a7>Heetch Engineering</a> and has been ported here for archiving purposes.</em></p><hr><p> </p><p>Plug is a cornerstone of Elixir and handling HTTP requests. It’s striking how simple it is to write one:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-elixir data-lang=elixir><span style=color:#66d9ef>defmodule</span> <span style=color:#a6e22e>Example.HelloWorldPlug</span> <span style=color:#66d9ef>do</span>
  <span style=color:#f92672>import</span> <span style=color:#a6e22e>Plug.Conn</span>

  <span style=color:#66d9ef>def</span> init(options), <span style=color:#e6db74>do</span>: options

  <span style=color:#66d9ef>def</span> call(conn, _opts) <span style=color:#66d9ef>do</span>
    conn
    <span style=color:#f92672>|&gt;</span> put_resp_content_type(<span style=color:#e6db74>&#34;text/plain&#34;</span>)
    <span style=color:#f92672>|&gt;</span> send_resp(<span style=color:#ae81ff>200</span>, <span style=color:#e6db74>&#34;Hello World!</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>)
  <span style=color:#66d9ef>end</span>
<span style=color:#66d9ef>end</span>
</code></pre></div><p>Yet simple does not necessarily mean that it is easy to use, especially when you’re getting started.</p><p>For example, if you look at the code above, it’s not obvious how to update it so it only acts on a specific path. That’s precisely what we’ll be looking at here.</p><h2 id=a-concrete-example>A concrete example<a hidden class=anchor aria-hidden=true href=#a-concrete-example>#</a></h2><p>An example of such a feature could be a health check handler. It’s an HTTP route (ex: <code>/_health_check</code>) that can be requested to know if a given web application is performing correctly or not.</p><ul><li>A <code>200</code> OK status code means that yes, it’s operating properly.</li><li>Anything else would mean that there is a problem and this instance of our application should not receive requests anymore.</li></ul><p>This way clients have a way to know if it’s running smoothly or not. For example, container orchestration solutions such as Kubernetes and Mesosphere DC/OS use this mechanism to know if it should kill Docker container running the app or not.</p><p>We will be using this use case during the rest of this post.</p><h2 id=why-not-just-use-plugrouter>Why not just use Plug.Router?<a hidden class=anchor aria-hidden=true href=#why-not-just-use-plugrouter>#</a></h2><p>If all we want is to match on a given path and respond with a specific response, Plug.Router sounds like an immediate solution. But what if we need to share the health check code among Phoenix apps and other Plug-based apps ?</p><p>A module using <code>Plug.Router</code> is a plug itself and thus could be shared. But can’t we just write a bare plug instead for the sake of simplicity?</p><p>Let’s see where we start if we’re not using Plug.Router to match specific routes. For a module to be a plug, it needs the <code>call/2</code> callback to be implemented.</p><p><code>call/2</code> takes two parameters, <code>conn</code> which is a <code>%Plug.Conn{}</code>, representing our connection to the client and <code>opts</code>, a set of options.</p><p>Looking at what is inside the <code>%Plug.Conn{}</code> struct, we can see that there are many interesting fields:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-elixir data-lang=elixir><span style=color:#75715e># (straight from https://github.com/elixir-plug/plug/blob/578cd973037bd3e8695817a0c4c69cac9d22db6a/lib/plug/conn.ex#L17-L32)</span>

<span style=color:#66d9ef>defmodule</span> <span style=color:#a6e22e>Plug.Conn</span> <span style=color:#66d9ef>do</span>
  <span style=color:#a6e22e>@moduledoc</span> <span style=color:#e6db74>&#34;&#34;&#34;
</span><span style=color:#e6db74>  (...)
</span><span style=color:#e6db74>  </span><span style=color:#960050;background-color:#1e0010>##</span><span style=color:#e6db74> Request fields
</span><span style=color:#e6db74>  * (...)
</span><span style=color:#e6db74>  * `host` - the requested host as a binary, example: `&#34;www.example.com&#34;`
</span><span style=color:#e6db74>  * `method` - the request method as a binary, example: `&#34;GET&#34;
</span><span style=color:#e6db74>  * `request_path` - the requested path, example: `/trailing/and//double//slashes/`
</span><span style=color:#e6db74>  * `path_info` - the path split into segments, example: `[&#34;hello&#34;, &#34;world&#34;]
</span><span style=color:#e6db74>  * `query_string` - the request query string as a binary, example: `&#34;foo=bar&#34;`
</span><span style=color:#e6db74>  * (...)
</span><span style=color:#e6db74>  (...)
</span><span style=color:#e6db74>  &#34;&#34;&#34;</span>
<span style=color:#66d9ef>end</span>
</code></pre></div><p>All these attributes being inside <code>conn</code>, we can pattern match against them. <code>request_path</code> is a good fit but it may contain trailing slashes. Instead, path_info is a list of each segment in the path, so we don’t have to bother with slashes at all, making it a better choice here.</p><p>Let’s see how it goes:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-elixir data-lang=elixir><span style=color:#66d9ef>defmodule</span> <span style=color:#a6e22e>HealthCheck.Plug</span> <span style=color:#66d9ef>do</span>
  <span style=color:#f92672>import</span> <span style=color:#a6e22e>Plug.Conn</span>
  <span style=color:#a6e22e>@behaviour</span> <span style=color:#a6e22e>Plug</span>

  <span style=color:#66d9ef>def</span> init(opts), <span style=color:#e6db74>do</span>: opts

  <span style=color:#75715e># path_info matches with health check path!</span>
  <span style=color:#66d9ef>def</span> call(conn <span style=color:#f92672>=</span> %{<span style=color:#e6db74>path_info</span>: [<span style=color:#e6db74>&#34;_health_check&#34;</span>]}, _opts) <span style=color:#66d9ef>do</span>
    conn
    <span style=color:#f92672>|&gt;</span> send_resp(<span style=color:#ae81ff>200</span>, <span style=color:#e6db74>&#34;ok&#34;</span>)
    <span style=color:#f92672>|&gt;</span> halt()
  <span style=color:#66d9ef>end</span>

  <span style=color:#75715e># nope, not for us, pass it down the chain.</span>
  <span style=color:#66d9ef>def</span> call(conn, _opts), <span style=color:#e6db74>do</span>: conn
<span style=color:#66d9ef>end</span>
</code></pre></div><p>So, in concrete terms, given that the health check path is <code>/_health_check</code>:</p><ul><li>If path_infomatches, respond with a <code>200</code> status code and halt the plug pipeline so that no other plugs will be called.</li><li>Otherwise, just pass the request down the chain to other plugs, like <code>plug :match</code> from <code>Plug.Router</code> or <code>Phoenix.Router</code>.</li></ul><h2 id=using-our-plug-with-plugrouter>Using our plug with Plug.Router<a hidden class=anchor aria-hidden=true href=#using-our-plug-with-plugrouter>#</a></h2><p>The <code>HealthCheck.Plug</code> can be used like any other plug but, if we want to use it within a <code>Plug.Router</code>, where it is inserted can change the outcome. Inserting it after <code>plug :dispatch</code> and <code>plug :match</code> will lead to the request being caught by the catch-all route before reaching our plug.</p><p>So the right way to use it is as follows:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-elixir data-lang=elixir><span style=color:#66d9ef>defmodule</span> <span style=color:#a6e22e>MyApp.Router</span> <span style=color:#66d9ef>do</span>
  <span style=color:#f92672>use</span> <span style=color:#a6e22e>Plug.Router</span>

  <span style=color:#75715e># This plug must be included **before** `plug :dispatch` and `plug :match`.</span>
  <span style=color:#75715e># Otherwise, the reponse will already be sent before it reaches the HealthCheck Plug.</span>
  plug <span style=color:#a6e22e>HealthCheck.Plug</span>

  plug <span style=color:#e6db74>:match</span>
  plug <span style=color:#e6db74>:dispatch</span>

  match _ <span style=color:#66d9ef>do</span>
    send_resp(conn, <span style=color:#ae81ff>404</span>, <span style=color:#e6db74>&#34;not found&#34;</span>)
  <span style=color:#66d9ef>end</span>
<span style=color:#66d9ef>end</span>
</code></pre></div><h2 id=using-our-plug-with-phoenix>Using our plug with Phoenix<a hidden class=anchor aria-hidden=true href=#using-our-plug-with-phoenix>#</a></h2><p>Phoenix works similarly. The plug needs to be inserted before any routing happens. Without diving into details, Phoenix implements its HTTP handler in two components, the endpoint which is a top-level plug and the router, where routes are defined.</p><p>So here, it’s required to insert our Plug in the endpoint, before inserting the router (exactly like we’ve seen previously).</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-elixir data-lang=elixir><span style=color:#66d9ef>defmodule</span> <span style=color:#a6e22e>MyAppWeb.Endpoint</span> <span style=color:#66d9ef>do</span>
  <span style=color:#f92672>use</span> <span style=color:#a6e22e>Phoenix.Endpoint</span>, <span style=color:#e6db74>otp_app</span>: <span style=color:#e6db74>:my_app</span>

  <span style=color:#75715e># This plug must absolutely be included **before** `plug MyAppWeb.Router`</span>
  plug <span style=color:#a6e22e>HealthCheck.Plug</span>
  plug <span style=color:#a6e22e>MyAppWeb.Router</span>
<span style=color:#66d9ef>end</span>
</code></pre></div><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>All that was done in here was to inspect what’s inside a connand pattern match against it. Very often, pattern matching is itself powerful enough to solve most problems.</p><p>In the end and like in other functional languages, looking at what structures are being carried around is really helpful and provides a lot of insight. It should be one of the first things to inspect when exploring code.</p></div><footer class=post-footer><ul class=post-tags><li><a href=http://jhchabran.dev/tags/code/>code</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2021 <a href=http://jhchabran.dev/>jhchabran</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script></body></html>